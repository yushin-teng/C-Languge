// 混合運算式 : 每個二元運算規定其兩個運算元要相同型態。
// 順序 long double > double > floar > ...(見p72)
// 兩個不同型態的運算元，值域較小之型態的運算元需轉成另一種型態。
// 轉換(coversion)是指型態之間的自動轉換
// cast(轉型)是指明確的將值轉成不同型態的動作，即型態轉換(casting)

// 盡可能避免將某一型態之值設定給值域較小之型態的變數

// 明確轉換 static_cast<目的型態> (expression) or dynamic cast
// static_cast<>(), const_cast<>(), dynamic_cast<>(), reinterpret_cast<>()
// 舊式轉型 (目前型態) expression，使用此轉型程式碼比較容易出錯，但仍廣泛使用。

// 型態大小，可透過sizeof()運算子取得配置記憶體大小的資訊
// 找出型別範圍，numeric_limits<型別>::max(),  numeric_limits<型別>::min(), numeric_limits<型別>::digits  (include <limits>)

// 位元運算子 bitwise operator 在位元層次處理整數變數，通常用在unsigned整數型態
// 位元移位運算子 bitwise shift operator 將整數變數的內容往左往右移動特定數目的字元。  >> 右移, <<左移，"只要沒有位元移失"，往左移n位元就是將值乘以n次的2 (*2^n)；往左移n位元就是將值除以n次的2 (/2^n)
// 若需要修改原始值，可用設定運算子 op= 即 >>= <<=運算。
// 有號整數的移位，右移富庶的實際情況會視編譯器的版本而定，所以你不能依賴它的運作。  應該都使用unsighed整數避免高位元的擴散。

// 在位元樣板上的邏輯運算
// 運算子   description
//  ~      這是位元補數運算子(bitwise complement operator)，為一元運算子，將其運算元的位元反轉，所以1變0，0變1
//  &      這是位元AND運算子(bitwise AND operator)，將其運算元對應的位元做AND。若對應的位元都是1，則結果為1。其他情況都為0。
//  ^      這是位元互斥OR運算子(bitwise exclusive OR operator)，將其運算元對應的位元操作互斥或。若對應位元不一樣，則結果為1。若對應位元相同則為0。
//  |      這是位元OR運算子(bitwise OR operator)，將其運算元對應的位元作OR。若兩個對應位元有一個位元為1，則結果為1。兩個都是0則結果為0。
// 以上已依優先權排列。

// 輸出運作子
// 運作子        功能
// dec          格式化整數以基數10(十進位)表示，預設方式
// hex          格式化整數以基數16(十六進位)表示
// oct          格式化整數以基數8(八進位)表示
// left         在輸出欄位中輸出值向左對齊，且在右邊填入填補字元。預設填補字元是空格
// right        在輸出欄位中輸出值向右對齊，且在左邊填入填補字元。預設填補字元是空格
// fixed        以固定小數點的方式輸出浮點值-即沒有指數
// scientific   以科學記號輸出浮點值-即假數+指數。
// showbase     在八進位的輸出前置0，在十六進位的輸出前置0x或0X。
// noshowbase   在八進位或十六進位時，沒有前置標記，這是預設方式。
// showpoint    對於浮點值顯示小數點及尾數0
// noshowpoint  showpoint的相反。這是預設方式
// showpos      對於正數顯示正號
// noshowpos    對於正數不顯示正號。這是預設方式
// uppercase    當以十六進位格式輸出整數時，以大寫的A至F顯示十六進位數字，若設定showbase則顯示0X(大寫)。若以科學記號輸出時，則以E(大寫)顯示指數。
// nouppercase  用小寫字母顯示上述各項值。這是預設方式
// boolalpha    以true和false顯示bool值。
// noboolalpha  以1和0顯示bool值。
// 可用cout << hed << left << fixed 連續設定。


// 列舉資料型態
// 變數屬於有限值域，且通常可用名稱參考這些值。 可將此系列變數定義成列舉(enumeration)。
// enumeration data type
// 定義列舉時，列舉內每個名稱會自動定義成一個固定的整數，由0起始開始。
// 不具名列舉
// 在定義列舉時可同時宣告變數，若不再宣告其他變數為此型態，則可省略列舉型態名稱。

// 資料型態的同義字
// typedef可以指定自己的資料型態名稱為另一種型態的第二個名稱，typedef可在程式使用的資料型態上提供彈性。

// 變數的生命週期，變數的生命都是有限的。 自動存在期 靜態存在期  動態存在期
// 變數的scope，在變數的scope中你才可以參考之，若在變數的scope外則不可參考。
// 此前定義的變數皆為自動變數automatic variale，其範疇為local scope 或 block scope，在含有此宣告的區塊結束處，此變數自動終止。 每次執行含有宣告自動變數之區塊的敘述時，會重新產生此變數，而且若有指定初值，則在每次產生時均會重新設定初值。

// 全域變數
// 宣告在所有區塊和類別之外的變數稱為全域變數(global variable)，有global scope。
// 全域變數的預設是靜態存在期(static storage duration)。其變數的生命週期從程式開始執行至程式結束。
// 若未對全域變數指定初值，預設會初值化為0。全域變數在main()執行前初始化，任意程式碼都可以使用他們。
// 範疇運算子 : 區域變數會遮蔽同名的全域變數，可用範疇運算子(scope resolution operator) (::)取得全域變數

// 靜態變數
// 你希望將變數定義為區塊的區域變數而且只能區域存取，但是在其宣告的區塊結束後依然能夠存在。
// 宣告為static的變數會與程式共存亡，即使他是宣告在區塊中而且只有在區塊中使用也依樣。 屬靜態存在期。
// 具靜態存在期的變數都會作初值化，不管你有無提供初值。不指定初值則初使化為0。  不同於自動變數，不初始化自動變數，則它們的值是最後記憶體程式留下的無用值。

// 特定型態修飾詞
// 有兩種型態修飾詞(modifier)可用來處理特定狀況，會應用於宣告變數 : register 和 volatile
// register修飾詞是用來表示變數是執行速度的關鍵，因此需置於機器的暫存器(register) (暫存器是特殊，高速的儲存裝置，不同於主記憶體，通常在處理器晶片中) 
// register int index = 0;  此敘述要求變數index使用暫存器，編譯器沒有義務接受此要求，而且在許多編譯器中不會因此而配置暫存器。 一般而言，你不應使用register，除非你絕對確定你在做什麼。
// volatile修飾詞是用來表示變數之值可由外部程序作非同步的修改，如中斷常式。這效果是降低編譯器可執行的最佳化。例如，當程式參考一個非-volatile變數時，編譯器也許可重複使用變數之前載入暫存器的現有值，以避免再次從記憶體讀取相同值的額外負擔，若變數宣告volatile，則每次使用時都要重新讀取一次。

// 宣告外部變數
// 若在另一個檔案(File2)的程式碼需要存取取其他檔案(File1)的變數，則於另一個檔案(File2)宣告extern 變數名稱，作外部變數使用。
// 另一個檔案(File2)在使用外部變數時，不可作初始化，否則變數會變成區域變數而非外部變數。

// 當設定敘述的左右運算元型態不同時，其右運算元的型態會自動轉換成左運算元的型態。 (當左運算元的型態不足以儲存右運算元的資料時，此轉換會導致資料遺失)